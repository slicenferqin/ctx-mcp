# 从"对话式编程"到"上下文工程"：AI编程提效的正确打开方式

> 为什么你的AI编程体验总是"demo很惊艳，实战很拉胯"？问题不在AI，在于你没有做好上下文管理。

## 一、当前困境：AI编程的理想与现实

### 1.1 你是否遇到过这些问题？

**Demo震撼，实战拉胯**
- 看别人演示：一句话生成完整应用，丝滑流畅
- 自己上手：生成的代码跑不起来，风格与项目格格不入，改了半天还不如自己写

**多轮对话，越改越乱**
- 第一轮：生成的代码有3个bug
- 第二轮：修了2个，新增了4个
- 第三轮：AI开始"忘记"之前的修改，又引入了老问题
- 最终：放弃，手动重写

**上下文丢失，反复解释**
- "我们用的是TypeScript，不是JavaScript"
- "我说过了，我们的API要返回统一格式"
- "这个项目用的是pnpm，不是npm"
- 每次对话都要重复交代背景，效率极低

**生成的代码"能跑"但"不能用"**
- 不符合团队代码规范
- 没有考虑现有架构
- 安全性、性能、可维护性都有问题
- Code Review时被打回重写

### 1.2 问题的根源：不是AI不行，是上下文不够

大多数人使用AI编程的方式：

```
用户: "帮我写一个用户登录接口"
AI: [生成一段通用代码]
用户: "不对，我们用的是Express"
AI: [重新生成]
用户: "错误码格式不对"
AI: [再次修改]
...无限循环
```

这种"盲人摸象"式的交互，本质问题是：**AI缺乏足够的上下文来做出正确决策**。

AI不知道：
- 你的项目用什么技术栈
- 你的团队有什么编码规范
- 你的现有代码是什么风格
- 你的架构设计是怎样的
- 你的业务领域有什么特殊约束

没有这些上下文，AI只能生成"通用正确"但"项目不适用"的代码。

---

## 二、解决方案：构建上下文管理体系

### 2.1 上下文三层架构

要让AI真正融入你的开发流程，需要构建三层上下文体系：

```
┌─────────────────────────────────────────────────────────┐
│  Layer 1: 项目上下文 (Project Context)                   │
│  - 代码库结构和现有实现                                   │
│  - 架构设计文档 (ADR)                                    │
│  - 数据模型和接口定义                                     │
│  来源: 代码仓库 + 项目文档                                │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Layer 2: 团队上下文 (Team Context)                      │
│  - 编码规范和命名约定                                     │
│  - API设计规范                                           │
│  - 安全和性能要求                                         │
│  - Git工作流和提交规范                                    │
│  来源: Skills文档 (Markdown)                             │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Layer 3: 技术栈上下文 (Tech Stack Context)              │
│  - 框架官方文档和最佳实践                                 │
│  - 库的API参考和使用示例                                  │
│  - 版本特定的breaking changes                            │
│  来源: Context7 / 官方文档 MCP                           │
└─────────────────────────────────────────────────────────┘
```

### 2.2 每层上下文的作用

| 层级 | 解决的问题 | 示例 |
|-----|-----------|------|
| 项目上下文 | "这个项目里怎么做的" | 现有的认证模块在哪、数据库schema是什么 |
| 团队上下文 | "我们团队怎么做的" | API返回格式、错误码规范、命名约定 |
| 技术栈上下文 | "这个技术应该怎么做" | React 18的最佳实践、Next.js 14的新特性 |

### 2.3 优先级原则

当不同层级的上下文冲突时，遵循以下优先级：

```
项目上下文 > 团队上下文 > 技术栈上下文 > AI默认行为
```

例如：
- 技术栈最佳实践推荐用 `camelCase`
- 但团队规范要求数据库字段用 `snake_case`
- AI应该遵循团队规范

### 2.4 静态上下文 vs 动态上下文

上下文管理有两种策略，各有适用场景：

#### 静态上下文（Static Context）

**定义：** 在任务开始前，一次性加载所有可能需要的上下文。

```
┌─────────────────────────────────┐
│ 启动时加载：                     │
│ - 所有Skills文档                 │
│ - 完整代码库索引                 │
│ - 全部架构文档                   │
│ - 所有技术栈文档                 │
└─────────────────────────────────┘
         ↓
    [AI开始工作]
```

**优点：**
- 信息完整，不会遗漏
- 适合小型项目

**缺点：**
- Token消耗巨大（可能超出上下文窗口）
- 大量无关信息干扰AI判断
- 启动慢，效率低

#### 动态上下文（Dynamic Context）⭐ 推荐

**定义：** 按需加载，渐进式发现，将中间结果卸载到文件系统。

```
┌─────────────────────────────────┐
│ 初始加载：                       │
│ - 核心Skills索引（按需加载）     │
│ - 项目结构概览                   │
└─────────────────────────────────┘
         ↓
    [AI分析需求]
         ↓
┌─────────────────────────────────┐
│ 动态探测：                       │
│ - 搜索相关代码文件               │
│ - 加载对应的Skills文档           │
│ - 查询特定技术栈文档             │
└─────────────────────────────────┘
         ↓
┌─────────────────────────────────┐
│ 结果卸载：                       │
│ - 分析结果写入临时文件           │
│ - 通过tail/read按需查看          │
│ - 释放上下文空间                 │
└─────────────────────────────────┘
```

**核心机制：**

1. **按需加载Skills**
```markdown
# .ai/skills/index.md (索引文件)

## 可用Skills
- `coding-standards.md` - 编码规范
- `api-conventions.md` - API设计规范
- `security-checklist.md` - 安全检查清单

## 使用方式
根据任务类型，AI自动加载相关Skills：
- 实现API → 加载 api-conventions.md
- 数据库操作 → 加载 database-guidelines.md
- 代码审查 → 加载 coding-standards.md
```

2. **探针式信息获取**
```bash
# 不是一次性读取整个代码库，而是：
grep -r "authentication" src/  # 探测认证相关代码
ls src/services/auth/          # 查看目录结构
head -n 50 src/services/auth/jwt.ts  # 读取关键文件片段
```

3. **结果卸载到文件系统**
```bash
# AI分析结果写入临时文件
echo "分析结果..." > /tmp/analysis-result.md

# 后续通过tail查看，而非占用上下文
tail -f /tmp/analysis-result.md

# 或按需读取特定部分
head -n 20 /tmp/analysis-result.md
```

**对比示例：**

| 场景 | 静态上下文 | 动态上下文 |
|-----|-----------|-----------|
| 实现登录接口 | 加载所有100个Skills文档 | 只加载 `api-conventions.md` + `security-checklist.md` |
| Token消耗 | 50K tokens | 5K tokens |
| 响应速度 | 慢（需处理大量无关信息） | 快（聚焦相关信息） |
| 准确性 | 可能被无关信息干扰 | 更精准（信息密度高） |

**动态上下文的最佳实践：**

1. **Skills设计为独立模块**
```
.ai/skills/
├── index.md              # 索引（始终加载）
├── core/                 # 核心规范（高频加载）
│   ├── coding-standards.md
│   └── git-workflow.md
├── api/                  # API相关（按需加载）
│   ├── rest-api.md
│   └── graphql.md
└── domain/               # 业务领域（按需加载）
    ├── payment.md
    └── notification.md
```

2. **使用探针工具**
- `grep` - 搜索关键词
- `find` - 定位文件
- `head/tail` - 查看文件片段
- `ls` - 探测目录结构

3. **中间结果持久化**
```bash
# 代码分析结果
AI分析 → /tmp/code-analysis.md

# 技术方案草稿
AI设计 → /tmp/tech-design.md

# 测试结果
测试输出 → /tmp/test-results.log
```

**为什么动态上下文更高效？**

```
静态上下文：
100个Skills × 2K tokens = 200K tokens（可能超限）
↓
AI需要在200K tokens中找到相关的5K tokens
↓
效率低，容易遗漏

动态上下文：
索引1K + 按需加载5K = 6K tokens
↓
AI直接处理高度相关的信息
↓
效率高，准确性强
```

---

## 三、落地实践：如何构建你的上下文体系

### 3.1 第一步：建立团队Skills库

在项目根目录创建 `.ai/skills/` 目录，存放团队约定：

```
.ai/
└── skills/
    ├── coding-standards.md    # 编码规范
    ├── api-conventions.md     # API设计规范
    ├── database-guidelines.md # 数据库设计规范
    ├── security-checklist.md  # 安全检查清单
    └── git-workflow.md        # Git工作流规范
```

**Skills文档编写原则：**

1. **结构化而非散文化**

```markdown
# ❌ 不好的写法
我们的API应该返回统一的格式，包含状态码和数据，
错误时要有错误信息...

# ✅ 好的写法
## API响应格式

### 成功响应
{
  "code": 0,
  "data": <业务数据>,
  "message": "success"
}

### 错误响应
{
  "code": <错误码>,
  "data": null,
  "message": "<错误描述>"
}

### 错误码范围
- 10000-19999: 业务错误
- 20000-29999: 系统错误
```

2. **包含正例和反例**

```markdown
## 命名规范

### 变量命名
✅ 正确: `userId`, `orderList`, `isActive`
❌ 错误: `user_id`, `orderArr`, `active`

### 函数命名
✅ 正确: `getUserById`, `createOrder`, `validateEmail`
❌ 错误: `get_user`, `newOrder`, `checkEmail`
```

3. **明确约束强度**

```markdown
## 约束级别

### MUST (必须遵守)
- 所有API必须进行身份验证
- 敏感数据必须加密存储

### SHOULD (应该遵守)
- 应该使用参数化查询防止SQL注入
- 应该对用户输入进行校验

### MAY (可选)
- 可以使用缓存提升性能
- 可以添加请求日志
```

### 3.2 第二步：配置MCP获取技术栈上下文

使用 Context7 等 MCP 服务获取技术栈的最新文档和最佳实践：

```json
// .ai/mcp-config.json
{
  "servers": {
    "context7": {
      "description": "获取技术栈官方文档和最佳实践"
    }
  }
}
```

**使用场景：**
- 查询框架的最新API用法
- 获取版本升级的breaking changes
- 了解官方推荐的最佳实践

### 3.3 第三步：建立项目上下文索引

确保AI能够访问和理解你的代码库：

1. **维护架构文档**
```markdown
# architecture.md

## 目录结构
src/
├── api/          # API路由层
├── services/     # 业务逻辑层
├── models/       # 数据模型层
├── utils/        # 工具函数
└── config/       # 配置文件

## 核心模块
- 认证模块: src/services/auth/
- 用户模块: src/services/user/
- 订单模块: src/services/order/
```

2. **记录架构决策 (ADR)**
```markdown
# ADR-001: 选择JWT作为认证方案

## 状态
已采纳

## 背景
需要实现无状态的用户认证...

## 决策
使用JWT + Refresh Token方案...

## 影响
- 所有API需要验证JWT
- Token过期时间设为2小时
```

### 3.4 第四步：设计工作流

将上下文管理融入开发流程：

```
需求输入
    ↓
┌─────────────────────────────────────┐
│ 1. 加载上下文                        │
│    - 读取相关Skills文档              │
│    - 查询技术栈最佳实践 (Context7)   │
│    - 分析现有代码结构                │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. 生成技术方案                      │
│    - 基于上下文设计实现方案          │
│    - 人工确认/调整                   │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 分步实现                          │
│    - 拆分为小任务                    │
│    - 每步生成 + 验证                 │
│    - 增量式推进                      │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. 验证检查                          │
│    - 代码规范检查                    │
│    - 单元测试                        │
│    - 人工Review关键路径              │
└─────────────────────────────────────┘
```

---

## 四、最佳实践清单

### 4.1 上下文管理

| 实践 | 说明 |
|-----|------|
| 维护Skills文档 | 将团队约定文档化，而非口口相传 |
| 结构化而非散文化 | 用代码示例、表格、清单，而非大段文字 |
| 版本控制Skills | Skills文档应该和代码一起版本管理 |
| 定期更新 | 技术栈升级、规范变更时同步更新文档 |

### 4.2 与AI交互

| 实践 | 说明 |
|-----|------|
| 先提供上下文，再提需求 | 不要上来就说"帮我写个接口" |
| 分步骤而非一步到位 | 复杂任务拆分成小步骤，逐步推进 |
| 明确约束条件 | 告诉AI"必须"和"不能"做什么 |
| 及时纠偏 | 发现偏差立即指出，不要等到最后 |

### 4.3 质量保障

| 实践 | 说明 |
|-----|------|
| 自动化检查 | ESLint、Prettier、类型检查作为基础门槛 |
| 测试覆盖 | AI生成的代码必须有对应测试 |
| 人工Review | 关键路径、安全相关代码必须人工审查 |
| 增量提交 | 小步提交，便于回滚和追溯 |

---

## 五、工具链推荐

### 5.1 上下文管理工具

| 工具 | 用途 |
|-----|------|
| MCP (Model Context Protocol) | AI与外部工具/数据的标准协议 |
| Context7 | 获取技术栈官方文档和最佳实践 |
| Codebase Indexing | 让AI理解你的代码库结构 |

### 5.2 Workflow工具

| 工具 | 用途 |
|-----|------|
| OpenSpec | 定义API规范，生成代码骨架 |
| SpecKit | 规范驱动的开发流程 |
| Custom Skills | 团队自定义的约束和指导文档 |

### 5.3 验证工具

| 工具 | 用途 |
|-----|------|
| ESLint/Prettier | 代码风格检查 |
| TypeScript | 类型安全检查 |
| Jest/Vitest | 单元测试 |
| Playwright | E2E测试 |

---

## 六、实施路径

### 阶段一：基础建设（1-2周）

- [ ] 梳理团队现有的编码规范，整理成Skills文档
- [ ] 建立 `.ai/skills/` 目录结构
- [ ] 配置基础的MCP服务（如Context7）
- [ ] 编写项目架构文档

### 阶段二：流程融合（2-4周）

- [ ] 在日常开发中使用Skills指导AI
- [ ] 收集AI生成代码的常见问题，补充到Skills
- [ ] 建立代码Review中的AI相关检查项
- [ ] 优化Skills文档的结构和表达

### 阶段三：持续优化（持续）

- [ ] 定期Review和更新Skills文档
- [ ] 探索更多MCP工具的集成
- [ ] 建立团队内的最佳实践分享机制
- [ ] 量化AI提效的效果指标

---

## 七、总结

AI编程的核心不是"如何写出更好的Prompt"，而是"如何构建更完善的上下文体系"。

**记住这个公式：**

```
AI编程效果 = AI能力 × 上下文质量
```

AI的能力是固定的（至少在你选定模型后），但上下文质量是你可以控制的变量。

**从今天开始：**

1. 停止"盲目对话"，开始"上下文工程"
2. 把团队约定从"口口相传"变成"文档沉淀"
3. 让AI成为"懂你项目的队友"，而不是"什么都不知道的新人"

当你的上下文体系足够完善时，AI编程的体验会从"反复纠错"变成"一次到位"。

---

*本文基于实际项目经验总结，欢迎交流讨论。*
